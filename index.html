import sys
import pandas as pd
import warnings
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
    QFileDialog, QLabel, QTableWidget, QTableWidgetItem,
    QMessageBox, QDateEdit, QTextEdit, QTabWidget
)
from PySide6.QtCore import QDate
from PySide6.QtGui import QColor
from openpyxl import Workbook
from openpyxl.styles import PatternFill
from datetime import datetime

warnings.simplefilter("ignore", UserWarning)

LOWER_IS_BETTER_KEYWORDS = ["drop", "bler", "congestion", "prb", "loss", "latency"]

def is_lower_better(kpi_name):
    kpi_name = kpi_name.lower()
    return any(keyword in kpi_name for keyword in LOWER_IS_BETTER_KEYWORDS)

class KPIComparator(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Pre vs Post KPI Comparator")
        self.resize(1800, 900)

        main_layout = QVBoxLayout()
        main_layout.addWidget(QLabel("ðŸ“Š KPI Comparator"))

        # Date selectors
        date_layout = QHBoxLayout()
        today = QDate.currentDate()
        post_end_default = today.addDays(-1)
        post_start_default = post_end_default.addDays(-2)
        pre_start_default = QDate(2025, 11, 22)
        pre_end_default = QDate(2025, 11, 24)

        self.pre_start = QDateEdit(pre_start_default)
        self.pre_end = QDateEdit(pre_end_default)
        self.post_start = QDateEdit(post_start_default)
        self.post_end = QDateEdit(post_end_default)

        for d in [self.pre_start, self.pre_end, self.post_start, self.post_end]:
            d.setCalendarPopup(True)
            d.setDisplayFormat("dd/MM/yyyy")

        date_layout.addWidget(QLabel("Pre Start"))
        date_layout.addWidget(self.pre_start)
        date_layout.addWidget(QLabel("Pre End"))
        date_layout.addWidget(self.pre_end)
        date_layout.addWidget(QLabel("Post Start"))
        date_layout.addWidget(self.post_start)
        date_layout.addWidget(QLabel("Post End"))
        date_layout.addWidget(self.post_end)
        main_layout.addLayout(date_layout)

        # Buttons
        btn_layout = QHBoxLayout()
        self.upload_btn = QPushButton("Upload Excel")
        self.upload_btn.clicked.connect(self.load_excel)
        self.export_btn = QPushButton("Export Result")
        self.export_btn.clicked.connect(self.export_excel)
        self.export_btn.setEnabled(False)
        btn_layout.addWidget(self.upload_btn)
        btn_layout.addWidget(self.export_btn)
        main_layout.addLayout(btn_layout)

        # Tabs: KPI Table + Degraded Summary
        self.tabs = QTabWidget()
        self.kpi_table = QTableWidget()
        self.summary_table = QTableWidget()
        self.tabs.addTab(self.kpi_table, "Pivoted KPI Table")
        self.tabs.addTab(self.summary_table, "Degraded KPI Summary")
        main_layout.addWidget(self.tabs)

        # Debug panel
        self.debug_panel = QTextEdit()
        self.debug_panel.setReadOnly(True)
        self.debug_panel.setPlaceholderText("Debug messages...")
        main_layout.addWidget(QLabel("ðŸ›  Debug / Issues Panel"))
        main_layout.addWidget(self.debug_panel)

        self.setLayout(main_layout)
        self.result_df = None
        self.summary_df = None
        self.site_col = None
        self.kpi_cols = None
        self.raw_df = None
        self.date_col = None

    def log_debug(self, msg):
        self.debug_panel.append(msg)

    def find_date_column(self, df):
        for c in df.columns:
            try:
                pd.to_datetime(df[c].dropna().iloc[0], dayfirst=True)
                return c
            except:
                continue
        return None

    def load_excel(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "Select Excel File", "", "Excel Files (*.xlsx *.xls)")
        if not file_path:
            self.log_debug("No file selected.")
            return

        try:
            self.log_debug(f"Reading file: {file_path}")
            df = pd.read_excel(file_path, header=0)
            df.columns = [str(c).strip() for c in df.columns]
            self.raw_df = df

            self.date_col = self.find_date_column(df)
            if not self.date_col:
                raise ValueError("No date column found")
            self.log_debug(f"Detected date column: {self.date_col}")

            df[self.date_col] = pd.to_datetime(df[self.date_col].astype(str).str.strip(), dayfirst=True, errors='coerce')

            # Site column detection
            if 'eNodeB Name' in df.columns:
                self.site_col = 'eNodeB Name'
            elif 'GBSC' in df.columns:
                self.site_col = 'GBSC'
            else:
                for c in df.columns:
                    if c != self.date_col and df[c].dtype == object:
                        self.site_col = c
                        break
            self.log_debug(f"Detected site column: {self.site_col}")

            # Numeric KPI columns
            self.kpi_cols = [c for c in df.columns if c not in [self.date_col, self.site_col] and pd.api.types.is_numeric_dtype(df[c])]
            self.log_debug(f"Detected KPI columns: {self.kpi_cols}")

            # Dates
            pre_s = pd.Timestamp(self.pre_start.date().toPython())
            pre_e = pd.Timestamp(self.pre_end.date().toPython())
            post_s = pd.Timestamp(self.post_start.date().toPython())
            post_e = pd.Timestamp(self.post_end.date().toPython())
            self.log_debug(f"Pre period: {pre_s.date()} to {pre_e.date()}")
            self.log_debug(f"Post period: {post_s.date()} to {post_e.date()}")

            pre_df = df[(df[self.date_col] >= pre_s) & (df[self.date_col] <= pre_e)]
            post_df = df[(df[self.date_col] >= post_s) & (df[self.date_col] <= post_e)]

            # Prepare pivoted data
            rows = []
            summary_rows = []
            sites = sorted(set(pre_df[self.site_col].unique()).union(post_df[self.site_col].unique()))

            for site in sites:
                row = {'Site': site}
                degraded_count = 0
                no_data_count = 0
                for kpi in self.kpi_cols:
                    pre_values = pre_df[pre_df[self.site_col] == site][kpi]
                    post_values = post_df[post_df[self.site_col] == site][kpi]

                    pre_days_count = len(pre_values.dropna())
                    post_days_count = len(post_values.dropna())

                    # Initialize no_fill_flag
                    no_fill_flag = False

                    # Both periods have no data â†’ No Data (gray)
                    if pre_days_count == 0 and post_days_count == 0:
                        res = "No Data"
                        pre_val = post_val = pct = pd.NA
                        no_data_count += 1
                        no_fill_flag = True
                    # Only one period missing â†’ show available value, no fill
                    elif pre_days_count == 0 or post_days_count == 0:
                        pre_val = pre_values.mean() if pre_days_count > 0 else pd.NA
                        post_val = post_values.mean() if post_days_count > 0 else pd.NA
                        res = "No Change"
                        pct = pd.NA
                        no_fill_flag = True
                    else:
                        pre_val = pre_values.mean()
                        post_val = post_values.mean()
                        if pre_val == post_val:
                            res = "No Change"
                            pct = pd.NA
                            no_fill_flag = False
                        else:
                            improved = (post_val < pre_val) if is_lower_better(kpi) else (post_val > pre_val)
                            res = "Improved" if improved else "Degraded"
                            pct = ((post_val - pre_val)/pre_val*100) if pre_val != 0 else pd.NA
                            no_fill_flag = False
                            if res == "Degraded":
                                degraded_count += 1

                    row[kpi] = {"text": f"Pre:{pre_val} | Post:{post_val} | Î”%:{pct} | {res}" if pd.notna(pct) else f"Pre:{pre_val} | Post:{post_val} | {res}",
                                "no_fill": no_fill_flag}

                row['Degraded KPI Count'] = degraded_count
                row['No Data Count'] = no_data_count
                rows.append(row)
                summary_rows.append({'Site': site, 'Degraded KPI Count': degraded_count, 'No Data Count': no_data_count})

            self.result_df = pd.DataFrame(rows)
            self.summary_df = pd.DataFrame(summary_rows)

            # Sort: most degraded first, mostly No Data last
            self.summary_df.sort_values(by=['Degraded KPI Count', 'No Data Count'], ascending=[False, True], inplace=True)
            self.result_df.set_index('Site', inplace=True)
            self.result_df = self.result_df.loc[self.summary_df['Site']].reset_index()

            self.populate_table()
            self.populate_summary()
            self.export_btn.setEnabled(True)
            self.log_debug("Comparison completed successfully.")

        except Exception as e:
            self.log_debug(f"Error: {str(e)}")
            QMessageBox.critical(self, "Error", str(e))

    def populate_table(self):
        df = self.result_df
        self.kpi_table.setRowCount(len(df))
        self.kpi_table.setColumnCount(len(df.columns))
        self.kpi_table.setHorizontalHeaderLabels(df.columns)

        for r in range(len(df)):
            for c in range(len(df.columns)):
                val = df.iat[r, c]
                if isinstance(val, dict):
                    item_text = val["text"]
                    item = QTableWidgetItem(item_text)
                    if c > 0 and not val.get("no_fill", False):
                        if "Degraded" in item_text:
                            item.setBackground(QColor(255, 100, 100))
                        elif "Improved" in item_text:
                            item.setBackground(QColor(150, 255, 150))
                        elif "No Change" in item_text:
                            item.setBackground(QColor(255, 255, 153))
                    # Do NOT call setBackground if no_fill â†’ stays default
                else:
                    item = QTableWidgetItem(str(val))
                self.kpi_table.setItem(r, c, item)

    def populate_summary(self):
        df = self.summary_df
        self.summary_table.setRowCount(len(df))
        self.summary_table.setColumnCount(len(df.columns))
        self.summary_table.setHorizontalHeaderLabels(df.columns)

        for r in range(len(df)):
            for c in range(len(df.columns)):
                item = QTableWidgetItem(str(df.iat[r, c]))
                if c == 1 and df.iat[r, c] > 0:
                    item.setBackground(QColor(255, 150, 150))
                elif c == 2 and df.iat[r, c] > 0:
                    item.setBackground(QColor(200, 200, 200))
                self.summary_table.setItem(r, c, item)

    def export_excel(self):
        if self.result_df is None:
            self.log_debug("No data to export.")
            return

        network_type = "LTE" if self.site_col == "eNodeB Name" else "GSM"
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        default_name = f"kpi_comparison_{network_type}_{timestamp}.xlsx"

        path, _ = QFileDialog.getSaveFileName(self, "Save Excel", default_name, "Excel Files (*.xlsx)")
        if not path:
            return

        wb = Workbook()
        ws = wb.active
        ws.title = "Pivoted KPI Table"

        # Write headers
        for idx, col in enumerate(self.result_df.columns, 1):
            ws.cell(row=1, column=idx, value=col)

        red_fill = PatternFill(start_color="FF6464", end_color="FF6464", fill_type="solid")
        green_fill = PatternFill(start_color="96FF96", end_color="96FF96", fill_type="solid")
        yellow_fill = PatternFill(start_color="FFFF99", end_color="FFFF99", fill_type="solid")
        gray_fill = PatternFill(start_color="C8C8C8", end_color="C8C8C8", fill_type="solid")

        for r_idx, row in enumerate(self.result_df.itertuples(index=False), 2):
            for c_idx, val in enumerate(row, 1):
                cell = ws.cell(row=r_idx, column=c_idx)
                if isinstance(val, dict):
                    cell.value = val["text"]
                    if not val.get("no_fill", False):
                        if "Degraded" in val["text"]:
                            cell.fill = red_fill
                        elif "Improved" in val["text"]:
                            cell.fill = green_fill
                        elif "No Change" in val["text"]:
                            cell.fill = yellow_fill
                    # Do not assign fill if no_fill â†’ default
                else:
                    cell.value = val

        # Degraded summary
        ws2 = wb.create_sheet("Degraded Summary")
        for idx, col in enumerate(self.summary_df.columns, 1):
            ws2.cell(row=1, column=idx, value=col)
        for r_idx, row in enumerate(self.summary_df.itertuples(index=False), 2):
            for c_idx, val in enumerate(row, 1):
                cell = ws2.cell(row=r_idx, column=c_idx, value=val)
                if c_idx == 2 and val > 0:
                    cell.fill = red_fill
                if c_idx == 3 and val > 0:
                    cell.fill = gray_fill

        wb.save(path)
        self.log_debug(f"Results exported to {path}")
        QMessageBox.information(self, "Export Completed", f"Excel exported to:\n{path}")


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = KPIComparator()
    window.show()
    sys.exit(app.exec())
